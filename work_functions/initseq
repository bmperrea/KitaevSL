/* histwv.c
 * 
 * Finds a weighted histogram of the inputs
 * This is a MEX file for MATLAB
*/

#include "mex.h"
#include "math.h"

/* actual code*/
void histwv(double *v, double *w, double min, double max, mwSize bins, double *histw, double *histv, mwSize vN, mwSize wM)
{
    /*The width of a bin */
    double delta = (max-min)/(bins-1);
    
	/*declarations */
    mwSize i;
	mwSize t;
    mwSize ind;
    
	/*loop through the values in v (and w) */
    for (i=0; i < vN ; i++) {
		#pragma loop(hint_parallel(8))
		/*compute the index of the corresponding bin */
		ind = (mwSize)round((v[i] - min) / delta);
		/*add one to the basic histogram */
		histv[ind]++;

		for (t = 0; t < wM; t++) {
			/*add the weight to the bin for weighted hist */
			histw[t + ind*wM] += w[t + i*wM];
		}

    }       
}

/* The gateway function */
void mexFunction(int nlhs, mxArray *plhs[],
                 int nrhs, const mxArray *prhs[])
{
/* variable declarations*/
    
    /*inputs */
    double *v; /*declares a pointer to the array */
	double *w; /*declares a pointer to the array */
    double min;
    double max;
    mwSize bins; /*replaces int in the Matlab context (compiler dependent) */
    
	/*outputs */
    double *histw; /*declares a pointer to the array */
    double *histv; /*declares a pointer to the array */
      
	/*getting values and pointers
		some careful checks */
    if( !mxIsDouble(prhs[0]) || 
         mxIsComplex(prhs[0])) {
        mexErrMsgIdAndTxt("histwv:inputs","v must be type double.");
    }
    if( !mxIsDouble(prhs[1]) || 
         mxIsComplex(prhs[1])) {
        mexErrMsgIdAndTxt("histwv:inputs","w must be type double.");
    }
    /* check that number of rows in first input argument is 1 */
    if(mxGetM(prhs[0])!=1) {
        mexErrMsgIdAndTxt("histwv:inputs","v must be a column vector.");
    }
    
	/*check the real scalars */
    if( !mxIsDouble(prhs[2]) || 
         mxIsComplex(prhs[2]) ||
         mxGetNumberOfElements(prhs[2])!=1 ||
            !mxIsDouble(prhs[3]) || 
         mxIsComplex(prhs[3]) ||
         mxGetNumberOfElements(prhs[3])!=1) {
        mexErrMsgIdAndTxt("histwv:inputs","Inputs min and max must be a scalar.");
    }
	/*check the double arrays */
    if( !mxIsDouble(prhs[0]) || 
         mxIsComplex(prhs[0]) || 
            !mxIsDouble(prhs[1]) || 
         mxIsComplex(prhs[1])) {
        mexErrMsgIdAndTxt("histwv:inputs","Inputs v and w must be a double.");
    }

	mwSize vN = mxGetN(prhs[0]); /* columns */
	mwSize wM = mxGetM(prhs[1]); /* rows */
	if (vN != mxGetN(prhs[1])) {
		mexErrMsgIdAndTxt("histwv:inputs", "Inputs v and w must have the same number of columns.");
	}

	/* check the integer */
	/* if( !mxIsInteger(prhs[4]) ) {
        mexErrMsgIdAndTxt("histwv:inputs","Input bins must be an integer.");
    } */
            
    v = mxGetPr(prhs[0]);
    w = mxGetPr(prhs[1]);
    min = mxGetScalar(prhs[2]);
    max = mxGetScalar(prhs[3]);
    bins= (mwSize)mxGetScalar(prhs[4]);
    
    if (nlhs == 2) { 
        plhs[0] = mxCreateDoubleMatrix(wM,bins,mxREAL);
        plhs[1] = mxCreateDoubleMatrix(1,bins,mxREAL);
        histw = mxGetPr(plhs[0]);
        histv = mxGetPr(plhs[1]);
    }
    else if (nlhs == 1) {
        plhs[0] = mxCreateDoubleMatrix(wM,bins,mxREAL);
        histw = mxGetPr(plhs[0]);
        histv = mxGetPr( mxCreateDoubleMatrix(1,bins,mxREAL) );
    }
    else{
        mexErrMsgIdAndTxt("histwv:outputs","Must be one or two inputs");   
    }    

/* code */
    histwv(v, w, min, max, bins, histw, histv, vN, wM);
    
}